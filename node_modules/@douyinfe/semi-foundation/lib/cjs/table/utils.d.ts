import { strings } from './constants';
import type { BaseEllipsis } from './foundation';
export declare function equalWith(value: any, other: any, customizer?: (...args: any[]) => boolean): boolean;
export declare function getColumnKey(column: any, keyPropNames: any[]): any;
/**
 *
 * @param {Array<number>} arr
 * @param {number} [beginIndex] begin index, included
 * @param {number} [endIndex] end index, not included
 * @returns {number}
 */
export declare function arrayAdd(arr?: any[], beginIndex?: number, endIndex?: number): number;
export declare function isLastLeftFixed(columns: Record<string, any>[], column: Record<string, any>, checkKeys?: string[]): boolean;
export declare function isFirstFixedRight(columns: Record<string, any>[], column: Record<string, any>, checkKeys?: string[]): boolean;
export declare function isAnyFixed(columns: Record<string, any>[], fixedSet?: (string | boolean)[]): boolean;
export declare function isAnyFixedRight(columns: Record<string, any>[]): boolean;
export declare function isFixedLeft(column: Record<string, any>): boolean;
export declare function isFixedRight(column: Record<string, any>): boolean;
export declare function isFixed(column: Record<string, any>): boolean;
export declare function isInnerColumnKey(key: string | number): boolean;
export declare function isExpandedColumn(column: Record<string, any>): boolean;
export declare function isScrollbarColumn(column: Record<string, any>): boolean;
export declare function isSelectionColumn(column: Record<string, any>): boolean;
export declare function filterColumns(columns: Record<string, any>[], ignoreKeys?: string[]): Record<string, any>[];
/**
 * get width of scroll bar
 * @param {Array} columns
 * @returns {Number|undefined}
 */
export declare function getScrollbarColumnWidth(columns?: Record<string, any>[]): any;
export declare function getRecordKey(record: Record<string, any>, rowKey: string | number | ((record: any) => string | number)): any;
/**
 * Determine whether the expandedRowKeys includes a key (rowKey will be added to expandedRowKeys when the expand button is clicked)
 * @param {*} expandedRowKeys
 * @param {*} key
 */
export declare function isExpanded(expandedRowKeys: (string | number)[], key: string | number): boolean;
/**
 * Determine whether the selectedKeysSet includes the key
 * @param {Set} selectedRowKeysSet
 * @param {String} key
 */
export declare function isSelected(selectedRowKeysSet: Set<string | number>, key: string | number): boolean;
/**
 * Whether the key is included in the disabledRowKeysSet
 * @param {Set} disabledRowKeysSet
 * @param {String} key
 */
export declare function isDisabled(disabledRowKeysSet: Set<string | number>, key: string | number): boolean;
export declare function getRecord(data: any[], recordKey: string | number, rowKey: string | number | ((record: any) => string | number)): any;
export declare function getRecordChildren(record: Record<string, any>, childrenRecordName: string): any;
export declare function genExpandedRowKey(recordKey?: string, suffix?: string): string;
export declare function getDefaultVirtualizedRowConfig(size?: string, sectionRow?: boolean): {
    height?: number;
    minHeight?: number;
};
export declare function flattenColumns(cols: Record<string, any>[], childrenColumnName?: string): Record<string, any>[];
export declare function assignColumnKeys(columns: Record<string, any>[], childrenColumnName?: string, level?: number): Record<string, any>[];
export declare function sliceColumnsByLevel(columns: any[], targetLevel?: number, childrenColumnName?: string, currentLevel?: number): any[];
export declare function getColumnsByLevel(columns: Record<string, any>[], targetLevel?: number, targetColumns?: Record<string, any>[], currentLevel?: number, childrenColumnName?: string): Record<string, any>[];
export declare function getAllLevelColumns(columns: Record<string, any>[], childrenColumnName?: string): any[];
export declare function getColumnByLevelIndex(columns: Record<string, any>[], index: number, level?: number, childrenColumnName?: string): any;
export declare function findColumn(columns: Record<string, any>[], column: Record<string, any>, childrenColumnName?: string): any;
export declare function expandBtnShouldInRow(props: ExpandBtnShouldInRowProps): boolean;
export declare type ExpandBtnShouldInRowProps = {
    expandedRowRender: (record?: Record<string, any>, index?: number, expanded?: boolean) => any;
    dataSource: Record<string, any>[];
    hideExpandedColumn: boolean;
    childrenRecordName: string;
    rowExpandable: (record?: Record<string, any>) => boolean;
};
/**
 * merge query
 * @param {*} query
 * @param {*} queries
 */
export declare function mergeQueries(query: Record<string, any>, queries?: Record<string, any>[]): Record<string, any>[];
/**
 * Replace the width of the newColumns column with the width of the column after resize
 * @param {Object[]} columns columns retain the column width after resize
 * @param {Object[]} newColumns
 */
export declare function withResizeWidth(columns: Record<string, any>[], newColumns: Record<string, any>[]): {
    [x: number]: Record<string, any>;
    length: number;
    toString(): string;
    toLocaleString(): string;
    pop(): Record<string, any>;
    push(...items: Record<string, any>[]): number;
    concat(...items: ConcatArray<Record<string, any>>[]): Record<string, any>[];
    concat(...items: (Record<string, any> | ConcatArray<Record<string, any>>)[]): Record<string, any>[];
    join(separator?: string): string;
    reverse(): Record<string, any>[];
    shift(): Record<string, any>;
    slice(start?: number, end?: number): Record<string, any>[];
    sort(compareFn?: (a: Record<string, any>, b: Record<string, any>) => number): Record<string, any>[];
    splice(start: number, deleteCount?: number): Record<string, any>[];
    splice(start: number, deleteCount: number, ...items: Record<string, any>[]): Record<string, any>[];
    unshift(...items: Record<string, any>[]): number;
    indexOf(searchElement: Record<string, any>, fromIndex?: number): number;
    lastIndexOf(searchElement: Record<string, any>, fromIndex?: number): number;
    every<S extends Record<string, any>>(predicate: (value: Record<string, any>, index: number, array: Record<string, any>[]) => value is S, thisArg?: any): this is S[];
    every(predicate: (value: Record<string, any>, index: number, array: Record<string, any>[]) => unknown, thisArg?: any): boolean;
    some(predicate: (value: Record<string, any>, index: number, array: Record<string, any>[]) => unknown, thisArg?: any): boolean;
    forEach(callbackfn: (value: Record<string, any>, index: number, array: Record<string, any>[]) => void, thisArg?: any): void;
    map<U>(callbackfn: (value: Record<string, any>, index: number, array: Record<string, any>[]) => U, thisArg?: any): U[];
    filter<S_1 extends Record<string, any>>(predicate: (value: Record<string, any>, index: number, array: Record<string, any>[]) => value is S_1, thisArg?: any): S_1[];
    filter(predicate: (value: Record<string, any>, index: number, array: Record<string, any>[]) => unknown, thisArg?: any): Record<string, any>[];
    reduce(callbackfn: (previousValue: Record<string, any>, currentValue: Record<string, any>, currentIndex: number, array: Record<string, any>[]) => Record<string, any>): Record<string, any>;
    reduce(callbackfn: (previousValue: Record<string, any>, currentValue: Record<string, any>, currentIndex: number, array: Record<string, any>[]) => Record<string, any>, initialValue: Record<string, any>): Record<string, any>;
    reduce<U_1>(callbackfn: (previousValue: U_1, currentValue: Record<string, any>, currentIndex: number, array: Record<string, any>[]) => U_1, initialValue: U_1): U_1;
    reduceRight(callbackfn: (previousValue: Record<string, any>, currentValue: Record<string, any>, currentIndex: number, array: Record<string, any>[]) => Record<string, any>): Record<string, any>;
    reduceRight(callbackfn: (previousValue: Record<string, any>, currentValue: Record<string, any>, currentIndex: number, array: Record<string, any>[]) => Record<string, any>, initialValue: Record<string, any>): Record<string, any>;
    reduceRight<U_2>(callbackfn: (previousValue: U_2, currentValue: Record<string, any>, currentIndex: number, array: Record<string, any>[]) => U_2, initialValue: U_2): U_2;
    find<S_2 extends Record<string, any>>(predicate: (this: void, value: Record<string, any>, index: number, obj: Record<string, any>[]) => value is S_2, thisArg?: any): S_2;
    find(predicate: (value: Record<string, any>, index: number, obj: Record<string, any>[]) => unknown, thisArg?: any): Record<string, any>;
    findIndex(predicate: (value: Record<string, any>, index: number, obj: Record<string, any>[]) => unknown, thisArg?: any): number;
    fill(value: Record<string, any>, start?: number, end?: number): Record<string, any>[];
    copyWithin(target: number, start: number, end?: number): Record<string, any>[];
    entries(): IterableIterator<[number, Record<string, any>]>;
    keys(): IterableIterator<number>;
    values(): IterableIterator<Record<string, any>>;
    includes(searchElement: Record<string, any>, fromIndex?: number): boolean;
    [Symbol.iterator](): IterableIterator<Record<string, any>>;
    [Symbol.unscopables](): {
        copyWithin: boolean;
        entries: boolean;
        fill: boolean;
        find: boolean;
        findIndex: boolean;
        keys: boolean;
        values: boolean;
    };
};
/**
 * Pure function version of the same function in table foundation
 * This is not accessible in getDerivedStateFromProps, so fork one out
 */
export declare function getAllDisabledRowKeys({ dataSource, getCheckboxProps, childrenRecordName, rowKey }: GetAllDisabledRowKeysProps): (string | number)[];
export interface GetAllDisabledRowKeysProps {
    dataSource: Record<string, any>[];
    getCheckboxProps: (record?: Record<string, any>) => any;
    childrenRecordName?: string;
    rowKey?: string | number | ((record: Record<string, any>) => string | number);
}
export declare function warnIfNoDataIndex(column: Record<string, any>): void;
/**
 * Whether is tree table
 */
export declare function isTreeTable({ dataSource, childrenRecordName }: {
    dataSource: Record<string, any>;
    childrenRecordName?: string;
}): boolean;
export declare function getRTLAlign(align: typeof strings.ALIGNS[number], direction?: 'ltr' | 'rtl'): typeof strings.ALIGNS[number];
export declare function shouldShowEllipsisTitle(ellipsis: BaseEllipsis): any;
